/* Generated by Yosys 0.15+31 (git sha1 a502570c2, gcc 11.2.1 -fPIC -Os) */

module bridge(wb__dat_w, wb__dat_r, wb__sel, wb__cyc, wb__stb, wb__we, wb__ack, rst, clk, csr__addr, csr__r_stb, csr__w_stb, csr__w_data, csr__r_data, wb__adr);
  reg \$auto$verilog_backend.cc:2083:dump_module$1  = 0;
  wire \$1 ;
  wire \$11 ;
  wire \$13 ;
  wire \$15 ;
  wire \$17 ;
  wire \$3 ;
  wire \$5 ;
  wire \$7 ;
  wire \$9 ;
  input clk;
  wire clk;
  output csr__addr;
  wire csr__addr;
  input [31:0] csr__r_data;
  wire [31:0] csr__r_data;
  output csr__r_stb;
  reg csr__r_stb;
  output [31:0] csr__w_data;
  reg [31:0] csr__w_data;
  output csr__w_stb;
  reg csr__w_stb;
  reg cycle = 1'h0;
  reg \cycle$next ;
  input rst;
  wire rst;
  output wb__ack;
  reg wb__ack = 1'h0;
  reg \wb__ack$next ;
  input wb__adr;
  wire wb__adr;
  input wb__cyc;
  wire wb__cyc;
  output [31:0] wb__dat_r;
  reg [31:0] wb__dat_r = 32'd0;
  reg [31:0] \wb__dat_r$next ;
  input [31:0] wb__dat_w;
  wire [31:0] wb__dat_w;
  input wb__sel;
  wire wb__sel;
  input wb__stb;
  wire wb__stb;
  input wb__we;
  wire wb__we;
  assign \$9  = wb__cyc & wb__stb;
  assign \$11  = wb__sel & wb__we;
  assign \$13  = wb__cyc & wb__stb;
  assign \$15  = wb__cyc & wb__stb;
  assign \$17  = wb__cyc & wb__stb;
  always @(posedge clk)
    cycle <= \cycle$next ;
  assign \$1  = wb__cyc & wb__stb;
  always @(posedge clk)
    wb__dat_r <= \wb__dat_r$next ;
  always @(posedge clk)
    wb__ack <= \wb__ack$next ;
  assign \$3  = ~ wb__we;
  assign \$5  = wb__sel & \$3 ;
  assign \$7  = wb__cyc & wb__stb;
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$1 ) begin end
    csr__r_stb = 1'h0;
    casez (\$1 )
      1'h1:
          casez (cycle)
            1'h0:
                csr__r_stb = \$5 ;
          endcase
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$1 ) begin end
    csr__w_data = 32'd0;
    casez (\$7 )
      1'h1:
          casez (cycle)
            1'h0:
                csr__w_data = wb__dat_w;
          endcase
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$1 ) begin end
    csr__w_stb = 1'h0;
    casez (\$9 )
      1'h1:
          casez (cycle)
            1'h0:
                csr__w_stb = \$11 ;
          endcase
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$1 ) begin end
    \cycle$next  = cycle;
    casez (\$13 )
      1'h1:
          casez (cycle)
            1'h0:
                \cycle$next  = 1'h1;
          endcase
    endcase
    casez (wb__ack)
      1'h1:
          \cycle$next  = 1'h0;
    endcase
    casez (rst)
      1'h1:
          \cycle$next  = 1'h0;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$1 ) begin end
    \wb__dat_r$next  = wb__dat_r;
    casez (\$15 )
      1'h1:
          (* full_case = 32'd1 *)
          casez (cycle)
            1'h0:
                /* empty */;
            default:
                \wb__dat_r$next  = csr__r_data;
          endcase
    endcase
    casez (rst)
      1'h1:
          \wb__dat_r$next  = 32'd0;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$1 ) begin end
    \wb__ack$next  = wb__ack;
    casez (\$17 )
      1'h1:
          (* full_case = 32'd1 *)
          casez (cycle)
            1'h0:
                /* empty */;
            default:
                \wb__ack$next  = 1'h1;
          endcase
    endcase
    casez (wb__ack)
      1'h1:
          \wb__ack$next  = 1'h0;
    endcase
    casez (rst)
      1'h1:
          \wb__ack$next  = 1'h0;
    endcase
  end
  assign csr__addr = wb__adr;
endmodule

module mux(bus_out, parity_out, clk_out, enabled, wb__adr, wb__dat_w, wb__sel, wb__cyc, wb__stb, wb__we, wb__dat_r, wb__ack, wb__stall, wb_ctrl__adr, wb_ctrl__dat_w, wb_ctrl__sel, wb_ctrl__cyc, wb_ctrl__stb, wb_ctrl__we, wb_ctrl__dat_r, wb_ctrl__ack
, wb_ctrl_stall, rst, clk, bus_in);
  reg \$auto$verilog_backend.cc:2083:dump_module$2  = 0;
  wire [8:0] \$1 ;
  wire \$10 ;
  wire [4:0] \$100 ;
  wire \$102 ;
  wire [4:0] \$104 ;
  wire [4:0] \$105 ;
  wire \$107 ;
  wire [4:0] \$109 ;
  wire [4:0] \$110 ;
  wire \$112 ;
  wire \$114 ;
  wire [4:0] \$116 ;
  wire [4:0] \$117 ;
  wire \$119 ;
  wire \$12 ;
  wire \$120 ;
  wire \$14 ;
  wire \$16 ;
  wire \$18 ;
  wire [8:0] \$2 ;
  wire \$20 ;
  wire \$22 ;
  wire \$24 ;
  wire \$26 ;
  wire \$28 ;
  wire \$30 ;
  wire \$32 ;
  wire \$34 ;
  wire \$36 ;
  wire \$38 ;
  wire \$4 ;
  wire \$40 ;
  wire \$42 ;
  wire \$44 ;
  wire \$46 ;
  wire \$48 ;
  wire \$50 ;
  wire [34:0] \$52 ;
  wire [31:0] \$53 ;
  wire [31:0] \$57 ;
  wire [31:0] \$59 ;
  wire \$6 ;
  wire \$61 ;
  wire [31:0] \$63 ;
  wire \$65 ;
  wire [31:0] \$67 ;
  wire [63:0] \$69 ;
  wire [63:0] \$71 ;
  wire \$73 ;
  wire [63:0] \$75 ;
  wire \$77 ;
  wire \$79 ;
  wire \$8 ;
  wire \$81 ;
  wire \$83 ;
  wire \$85 ;
  wire \$87 ;
  wire \$89 ;
  wire \$91 ;
  wire [34:0] \$93 ;
  wire [31:0] \$94 ;
  wire \$97 ;
  wire [4:0] \$99 ;
  reg [31:0] addr = 32'd0;
  reg [31:0] \addr$next ;
  wire bridge_wb__ack;
  wire bridge_wb__adr;
  wire bridge_wb__cyc;
  wire [31:0] bridge_wb__dat_r;
  wire [31:0] bridge_wb__dat_w;
  wire bridge_wb__sel;
  wire bridge_wb__stb;
  wire bridge_wb__we;
  input [7:0] bus_in;
  wire [7:0] bus_in;
  output [7:0] bus_out;
  reg [7:0] bus_out = 8'h00;
  reg [7:0] \bus_out$next ;
  input clk;
  wire clk;
  output clk_out;
  reg clk_out;
  wire clk_strobe;
  reg [7:0] clock_counter = 8'h00;
  reg [7:0] \clock_counter$next ;
  wire [2:0] clock_divisor;
  wire clock_strobe;
  reg [31:0] \config  = 32'd1;
  reg [31:0] \config$next ;
  reg [3:0] count = 4'h0;
  reg [3:0] \count$next ;
  reg [63:0] data = 64'h0000000000000000;
  reg [63:0] \data$next ;
  output enabled;
  wire enabled;
  wire is_read;
  wire is_write;
  wire [31:0] mux_config_csr__r_data;
  wire [31:0] mux_config_csr__w_data;
  wire mux_config_csr__w_stb;
  wire mux_csr__addr;
  wire [31:0] mux_csr__r_data;
  wire mux_csr__r_stb;
  wire [31:0] mux_csr__w_data;
  wire mux_csr__w_stb;
  wire [31:0] mux_status_csr__r_data;
  wire [31:0] mux_status_csr__w_data;
  wire mux_status_csr__w_stb;
  output parity_out;
  wire parity_out;
  reg prev_clk = 1'h0;
  reg \prev_clk$next ;
  input rst;
  wire rst;
  reg [34:0] s;
  reg [34:0] \s$56 ;
  reg [7:0] sel = 8'h00;
  reg [7:0] \sel$next ;
  (* enum_base_type = "StateEnum" *)
  (* enum_value_0000 = "IDLE" *)
  (* enum_value_0001 = "WRITE_CMD" *)
  (* enum_value_0010 = "READ_CMD" *)
  (* enum_value_0011 = "WRITE_ADDR" *)
  (* enum_value_0100 = "READ_ADDR" *)
  (* enum_value_0101 = "WRITE_SEL" *)
  (* enum_value_0110 = "READ_SEL" *)
  (* enum_value_0111 = "WRITE_DATA" *)
  (* enum_value_1000 = "READ_DATA" *)
  (* enum_value_1001 = "WRITE_ACK" *)
  (* enum_value_1010 = "READ_ACK" *)
  (* enum_value_1011 = "WISHBONE_ACK" *)
  reg [3:0] state = 4'h0;
  reg [3:0] \state$next ;
  reg [31:0] status = 32'd0;
  reg [31:0] \status$next ;
  output wb__ack;
  reg wb__ack = 1'h0;
  reg \wb__ack$next ;
  input [28:0] wb__adr;
  wire [28:0] wb__adr;
  input wb__cyc;
  wire wb__cyc;
  output [63:0] wb__dat_r;
  wire [63:0] wb__dat_r;
  input [63:0] wb__dat_w;
  wire [63:0] wb__dat_w;
  input [7:0] wb__sel;
  wire [7:0] wb__sel;
  output wb__stall;
  reg wb__stall;
  input wb__stb;
  wire wb__stb;
  input wb__we;
  wire wb__we;
  output wb_ctrl__ack;
  wire wb_ctrl__ack;
  input [29:0] wb_ctrl__adr;
  wire [29:0] wb_ctrl__adr;
  input wb_ctrl__cyc;
  wire wb_ctrl__cyc;
  output [31:0] wb_ctrl__dat_r;
  wire [31:0] wb_ctrl__dat_r;
  input [31:0] wb_ctrl__dat_w;
  wire [31:0] wb_ctrl__dat_w;
  input [3:0] wb_ctrl__sel;
  wire [3:0] wb_ctrl__sel;
  input wb_ctrl__stb;
  wire wb_ctrl__stb;
  input wb_ctrl__we;
  wire wb_ctrl__we;
  output wb_ctrl_stall;
  reg wb_ctrl_stall;
  assign \$100  = count - 1'h1;
  assign \$102  = | count;
  assign \$105  = count - 1'h1;
  assign \$107  = | count;
  assign \$10  = clock_divisor == 2'h3;
  assign \$110  = count - 1'h1;
  assign \$112  = bus_in == 8'h82;
  assign \$114  = | count;
  assign \$117  = count - 1'h1;
  assign \$120  = ^ bus_out;
  assign \$119  = ~ \$120 ;
  always @(posedge clk)
    clock_counter <= \clock_counter$next ;
  always @(posedge clk)
    prev_clk <= \prev_clk$next ;
  always @(posedge clk)
    bus_out <= \bus_out$next ;
  always @(posedge clk)
    wb__ack <= \wb__ack$next ;
  always @(posedge clk)
    addr <= \addr$next ;
  always @(posedge clk)
    data <= \data$next ;
  always @(posedge clk)
    sel <= \sel$next ;
  assign \$12  = clock_divisor == 3'h4;
  always @(posedge clk)
    state <= \state$next ;
  always @(posedge clk)
    count <= \count$next ;
  always @(posedge clk)
    \config  <= \config$next ;
  always @(posedge clk)
    status <= \status$next ;
  assign \$14  = clock_divisor == 3'h5;
  assign \$16  = clock_divisor == 3'h6;
  assign \$18  = clock_divisor == 3'h7;
  assign \$20  = ~ prev_clk;
  assign \$22  = \$20  & clk_out;
  assign \$24  = wb__stb & wb__cyc;
  assign \$26  = \$24  & wb__we;
  assign \$28  = wb__stb & wb__cyc;
  assign \$2  = clock_counter + 1'h1;
  assign \$30  = ~ wb__we;
  assign \$32  = \$28  & \$30 ;
  assign \$34  = ~ wb__cyc;
  assign \$36  = ~ wb__ack;
  assign \$38  = ~ wb_ctrl__cyc;
  assign \$40  = ~ wb_ctrl__ack;
  assign \$42  = | count;
  assign \$44  = | count;
  assign \$46  = | count;
  assign \$48  = bus_in == 8'h83;
  assign \$4  = ! clock_divisor;
  assign \$50  = | count;
  assign \$52  = + \$53 ;
  assign \$57  = + addr[31:8];
  assign \$59  = + addr[31:8];
  assign \$61  = | count;
  assign \$63  = + addr[31:8];
  assign \$65  = | count;
  assign \$67  = + addr[31:8];
  assign \$6  = clock_divisor == 1'h1;
  assign \$69  = + data[63:8];
  assign \$71  = + data[63:8];
  assign \$73  = | count;
  assign \$75  = + data[63:8];
  assign \$77  = bus_in == 8'h82;
  assign \$79  = | count;
  assign \$81  = | count;
  assign \$83  = | count;
  assign \$85  = | count;
  assign \$87  = bus_in == 8'h83;
  assign \$8  = clock_divisor == 2'h2;
  assign \$89  = bus_in == 8'h82;
  assign \$91  = | count;
  assign \$93  = + \$94 ;
  assign \$97  = | count;
  bridge bridge (
    .clk(clk),
    .csr__addr(mux_csr__addr),
    .csr__r_data(mux_csr__r_data),
    .csr__r_stb(mux_csr__r_stb),
    .csr__w_data(mux_csr__w_data),
    .csr__w_stb(mux_csr__w_stb),
    .rst(rst),
    .wb__ack(bridge_wb__ack),
    .wb__adr(bridge_wb__adr),
    .wb__cyc(bridge_wb__cyc),
    .wb__dat_r(bridge_wb__dat_r),
    .wb__dat_w(bridge_wb__dat_w),
    .wb__sel(bridge_wb__sel),
    .wb__stb(bridge_wb__stb),
    .wb__we(bridge_wb__we)
  );
  \mux$1  mux (
    .clk(clk),
    .config_csr__r_data(mux_config_csr__r_data),
    .config_csr__w_data(mux_config_csr__w_data),
    .config_csr__w_stb(mux_config_csr__w_stb),
    .csr__addr(mux_csr__addr),
    .csr__r_data(mux_csr__r_data),
    .csr__r_stb(mux_csr__r_stb),
    .csr__w_data(mux_csr__w_data),
    .csr__w_stb(mux_csr__w_stb),
    .rst(rst),
    .status_csr__r_data(mux_status_csr__r_data),
    .status_csr__w_data(mux_status_csr__w_data),
    .status_csr__w_stb(mux_status_csr__w_stb)
  );
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$2 ) begin end
    (* full_case = 32'd1 *)
    casez (\$34 )
      1'h1:
          wb__stall = 1'h0;
      default:
          wb__stall = \$36 ;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$2 ) begin end
    (* full_case = 32'd1 *)
    casez (\$38 )
      1'h1:
          wb_ctrl_stall = 1'h0;
      default:
          wb_ctrl_stall = \$40 ;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$2 ) begin end
    \bus_out$next  = bus_out;
    casez (state)
      4'h0:
        begin
          \bus_out$next  = 8'h00;
          casez (clock_strobe)
            1'h1:
                casez ({ is_read, is_write })
                  2'b?1:
                      \bus_out$next  = 8'h03;
                  2'b1?:
                      \bus_out$next  = 8'h02;
                endcase
          endcase
        end
      4'h1:
          casez (clock_strobe)
            1'h1:
                \bus_out$next  = addr[7:0];
          endcase
      4'h2:
          casez (clock_strobe)
            1'h1:
                \bus_out$next  = addr[7:0];
          endcase
      4'h3:
          casez (clock_strobe)
            1'h1:
                (* full_case = 32'd1 *)
                casez (\$42 )
                  1'h1:
                      \bus_out$next  = addr[7:0];
                  default:
                      \bus_out$next  = sel;
                endcase
          endcase
      4'h4:
          casez (clock_strobe)
            1'h1:
                (* full_case = 32'd1 *)
                casez (\$44 )
                  1'h1:
                      \bus_out$next  = addr[7:0];
                  default:
                      \bus_out$next  = sel;
                endcase
          endcase
      4'h5:
          casez (clock_strobe)
            1'h1:
                \bus_out$next  = data[7:0];
          endcase
      4'h6:
          casez (clock_strobe)
            1'h1:
                \bus_out$next  = 8'h00;
          endcase
      4'h7:
          casez (clock_strobe)
            1'h1:
                (* full_case = 32'd1 *)
                casez (\$46 )
                  1'h1:
                      \bus_out$next  = data[7:0];
                  default:
                      \bus_out$next  = 8'h00;
                endcase
          endcase
    endcase
    casez (rst)
      1'h1:
          \bus_out$next  = 8'h00;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$2 ) begin end
    \wb__ack$next  = wb__ack;
    casez (state)
      4'h0:
          \wb__ack$next  = 1'h0;
      4'h1:
          /* empty */;
      4'h2:
          /* empty */;
      4'h3:
          /* empty */;
      4'h4:
          /* empty */;
      4'h5:
          /* empty */;
      4'h6:
          /* empty */;
      4'h7:
          /* empty */;
      4'h9:
          casez (clock_strobe)
            1'h1:
                casez (\$48 )
                  1'h1:
                      \wb__ack$next  = 1'h1;
                endcase
          endcase
      4'ha:
          /* empty */;
      4'h8:
          casez (clock_strobe)
            1'h1:
                (* full_case = 32'd1 *)
                casez (\$50 )
                  1'h1:
                      /* empty */;
                  default:
                      \wb__ack$next  = 1'h1;
                endcase
          endcase
      4'hb:
          \wb__ack$next  = 1'h0;
    endcase
    casez (rst)
      1'h1:
          \wb__ack$next  = 1'h0;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$2 ) begin end
    s = 35'h000000000;
    casez (state)
      4'h0:
          casez (clock_strobe)
            1'h1:
                casez ({ is_read, is_write })
                  2'b?1:
                      s = \$52 ;
                endcase
          endcase
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$2 ) begin end
    \addr$next  = addr;
    casez (state)
      4'h0:
          casez (clock_strobe)
            1'h1:
                casez ({ is_read, is_write })
                  2'b?1:
                      \addr$next  = s[31:0];
                  2'b1?:
                      \addr$next  = \s$56 [31:0];
                endcase
          endcase
      4'h1:
          casez (clock_strobe)
            1'h1:
                \addr$next  = \$57 ;
          endcase
      4'h2:
          casez (clock_strobe)
            1'h1:
                \addr$next  = \$59 ;
          endcase
      4'h3:
          casez (clock_strobe)
            1'h1:
                casez (\$61 )
                  1'h1:
                      \addr$next  = \$63 ;
                endcase
          endcase
      4'h4:
          casez (clock_strobe)
            1'h1:
                casez (\$65 )
                  1'h1:
                      \addr$next  = \$67 ;
                endcase
          endcase
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$2 ) begin end
    \data$next  = data;
    casez (state)
      4'h0:
          casez (clock_strobe)
            1'h1:
                casez ({ is_read, is_write })
                  2'b?1:
                      \data$next  = wb__dat_w;
                endcase
          endcase
      4'h1:
          /* empty */;
      4'h2:
          /* empty */;
      4'h3:
          /* empty */;
      4'h4:
          /* empty */;
      4'h5:
          casez (clock_strobe)
            1'h1:
                \data$next  = \$69 ;
          endcase
      4'h6:
          casez (clock_strobe)
            1'h1:
                \data$next  = \$71 ;
          endcase
      4'h7:
          casez (clock_strobe)
            1'h1:
                casez (\$73 )
                  1'h1:
                      \data$next  = \$75 ;
                endcase
          endcase
      4'h9:
          /* empty */;
      4'ha:
          casez (clock_strobe)
            1'h1:
                casez (\$77 )
                  1'h1:
                      \data$next  = 64'h0000000000000000;
                endcase
          endcase
      4'h8:
          casez (clock_strobe)
            1'h1:
                casez (\$79 )
                  1'h1:
                      \data$next  = { bus_in, data[63:8] };
                endcase
          endcase
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$2 ) begin end
    \sel$next  = sel;
    casez (state)
      4'h0:
          casez (clock_strobe)
            1'h1:
                casez ({ is_read, is_write })
                  2'b?1:
                      \sel$next  = wb__sel;
                endcase
          endcase
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$2 ) begin end
    \state$next  = state;
    casez (state)
      4'h0:
          casez (clock_strobe)
            1'h1:
                casez ({ is_read, is_write })
                  2'b?1:
                      \state$next  = 4'h1;
                  2'b1?:
                      \state$next  = 4'h2;
                endcase
          endcase
      4'h1:
          casez (clock_strobe)
            1'h1:
                \state$next  = 4'h3;
          endcase
      4'h2:
          casez (clock_strobe)
            1'h1:
                \state$next  = 4'h4;
          endcase
      4'h3:
          casez (clock_strobe)
            1'h1:
                (* full_case = 32'd1 *)
                casez (\$81 )
                  1'h1:
                      /* empty */;
                  default:
                      \state$next  = 4'h5;
                endcase
          endcase
      4'h4:
          casez (clock_strobe)
            1'h1:
                (* full_case = 32'd1 *)
                casez (\$83 )
                  1'h1:
                      /* empty */;
                  default:
                      \state$next  = 4'h6;
                endcase
          endcase
      4'h5:
          casez (clock_strobe)
            1'h1:
                \state$next  = 4'h7;
          endcase
      4'h6:
          casez (clock_strobe)
            1'h1:
                \state$next  = 4'ha;
          endcase
      4'h7:
          casez (clock_strobe)
            1'h1:
                (* full_case = 32'd1 *)
                casez (\$85 )
                  1'h1:
                      /* empty */;
                  default:
                      \state$next  = 4'h9;
                endcase
          endcase
      4'h9:
          casez (clock_strobe)
            1'h1:
                casez (\$87 )
                  1'h1:
                      \state$next  = 4'hb;
                endcase
          endcase
      4'ha:
          casez (clock_strobe)
            1'h1:
                casez (\$89 )
                  1'h1:
                      \state$next  = 4'h8;
                endcase
          endcase
      4'h8:
          casez (clock_strobe)
            1'h1:
                (* full_case = 32'd1 *)
                casez (\$91 )
                  1'h1:
                      /* empty */;
                  default:
                      \state$next  = 4'hb;
                endcase
          endcase
      4'hb:
          \state$next  = 4'h0;
    endcase
    casez (rst)
      1'h1:
          \state$next  = 4'h0;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$2 ) begin end
    \s$56  = 35'h000000000;
    casez (state)
      4'h0:
          casez (clock_strobe)
            1'h1:
                casez ({ is_read, is_write })
                  2'b?1:
                      /* empty */;
                  2'b1?:
                      \s$56  = \$93 ;
                endcase
          endcase
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$2 ) begin end
    \clock_counter$next  = \$2 [7:0];
    casez (rst)
      1'h1:
          \clock_counter$next  = 8'h00;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$2 ) begin end
    \count$next  = count;
    casez (state)
      4'h0:
          /* empty */;
      4'h1:
          casez (clock_strobe)
            1'h1:
                \count$next  = 4'h3;
          endcase
      4'h2:
          casez (clock_strobe)
            1'h1:
                \count$next  = 4'h3;
          endcase
      4'h3:
          casez (clock_strobe)
            1'h1:
                casez (\$97 )
                  1'h1:
                      \count$next  = \$100 [3:0];
                endcase
          endcase
      4'h4:
          casez (clock_strobe)
            1'h1:
                casez (\$102 )
                  1'h1:
                      \count$next  = \$105 [3:0];
                endcase
          endcase
      4'h5:
          casez (clock_strobe)
            1'h1:
                \count$next  = 4'h7;
          endcase
      4'h6:
          casez (clock_strobe)
            1'h1:
                \count$next  = 4'h7;
          endcase
      4'h7:
          casez (clock_strobe)
            1'h1:
                casez (\$107 )
                  1'h1:
                      \count$next  = \$110 [3:0];
                endcase
          endcase
      4'h9:
          /* empty */;
      4'ha:
          casez (clock_strobe)
            1'h1:
                casez (\$112 )
                  1'h1:
                      \count$next  = 4'h8;
                endcase
          endcase
      4'h8:
          casez (clock_strobe)
            1'h1:
                casez (\$114 )
                  1'h1:
                      \count$next  = \$117 [3:0];
                endcase
          endcase
    endcase
    casez (rst)
      1'h1:
          \count$next  = 4'h0;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$2 ) begin end
    clk_out = 1'h0;
    casez (\$4 )
      1'h1:
          clk_out = clock_counter[0];
    endcase
    casez (\$6 )
      1'h1:
          clk_out = clock_counter[1];
    endcase
    casez (\$8 )
      1'h1:
          clk_out = clock_counter[2];
    endcase
    casez (\$10 )
      1'h1:
          clk_out = clock_counter[3];
    endcase
    casez (\$12 )
      1'h1:
          clk_out = clock_counter[4];
    endcase
    casez (\$14 )
      1'h1:
          clk_out = clock_counter[5];
    endcase
    casez (\$16 )
      1'h1:
          clk_out = clock_counter[6];
    endcase
    casez (\$18 )
      1'h1:
          clk_out = clock_counter[7];
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$2 ) begin end
    \config$next  = \config ;
    casez (mux_config_csr__w_stb)
      1'h1:
          \config$next  = mux_config_csr__w_data;
    endcase
    casez (rst)
      1'h1:
          \config$next  = 32'd1;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$2 ) begin end
    \status$next  = status;
    casez (mux_status_csr__w_stb)
      1'h1:
          \status$next  = mux_status_csr__w_data;
    endcase
    casez (rst)
      1'h1:
          \status$next  = 32'd0;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$2 ) begin end
    \prev_clk$next  = clk_out;
    casez (rst)
      1'h1:
          \prev_clk$next  = 1'h0;
    endcase
  end
  assign \$1  = \$2 ;
  assign \$99  = \$100 ;
  assign \$104  = \$105 ;
  assign \$109  = \$110 ;
  assign \$116  = \$117 ;
  assign mux_status_csr__r_data = status;
  assign mux_config_csr__r_data = \config ;
  assign wb_ctrl__ack = bridge_wb__ack;
  assign bridge_wb__we = wb_ctrl__we;
  assign bridge_wb__stb = wb_ctrl__stb;
  assign bridge_wb__cyc = wb_ctrl__cyc;
  assign bridge_wb__sel = wb_ctrl__sel[0];
  assign wb_ctrl__dat_r = bridge_wb__dat_r;
  assign bridge_wb__dat_w = wb_ctrl__dat_w;
  assign bridge_wb__adr = wb_ctrl__adr[0];
  assign parity_out = \$119 ;
  assign is_read = \$32 ;
  assign is_write = \$26 ;
  assign wb__dat_r = data;
  assign clk_strobe = clock_strobe;
  assign clock_strobe = \$22 ;
  assign enabled = \config [3];
  assign clock_divisor = \config [2:0];
  assign \$53  = { wb__adr, 3'h0 };
  assign \$94  = { wb__adr, 3'h0 };
endmodule

module \mux$1 (status_csr__r_data, config_csr__w_stb, config_csr__w_data, status_csr__w_stb, status_csr__w_data, rst, clk, csr__addr, csr__r_stb, csr__w_stb, csr__w_data, csr__r_data, config_csr__r_data);
  reg \$auto$verilog_backend.cc:2083:dump_module$3  = 0;
  wire [1:0] \$1 ;
  wire [31:0] \$11 ;
  wire [31:0] \$13 ;
  wire [1:0] \$2 ;
  wire [1:0] \$4 ;
  wire [1:0] \$5 ;
  wire [31:0] \$7 ;
  wire [31:0] \$9 ;
  input clk;
  wire clk;
  input [31:0] config_csr__r_data;
  wire [31:0] config_csr__r_data;
  reg config_csr__r_stb;
  reg [31:0] config_csr__shadow = 32'd0;
  reg [31:0] \config_csr__shadow$next ;
  reg config_csr__shadow_en = 1'h0;
  reg \config_csr__shadow_en$next ;
  output [31:0] config_csr__w_data;
  wire [31:0] config_csr__w_data;
  output config_csr__w_stb;
  reg config_csr__w_stb = 1'h0;
  reg \config_csr__w_stb$next ;
  input csr__addr;
  wire csr__addr;
  output [31:0] csr__r_data;
  wire [31:0] csr__r_data;
  input csr__r_stb;
  wire csr__r_stb;
  input [31:0] csr__w_data;
  wire [31:0] csr__w_data;
  input csr__w_stb;
  wire csr__w_stb;
  input rst;
  wire rst;
  input [31:0] status_csr__r_data;
  wire [31:0] status_csr__r_data;
  reg status_csr__r_stb;
  reg [31:0] status_csr__shadow = 32'd0;
  reg [31:0] \status_csr__shadow$next ;
  reg status_csr__shadow_en = 1'h0;
  reg \status_csr__shadow_en$next ;
  output [31:0] status_csr__w_data;
  wire [31:0] status_csr__w_data;
  output status_csr__w_stb;
  reg status_csr__w_stb = 1'h0;
  reg \status_csr__w_stb$next ;
  assign \$9  = 1'h0 | \$7 ;
  assign \$11  = status_csr__shadow_en ? status_csr__shadow : 32'd0;
  assign \$13  = \$9  | \$11 ;
  always @(posedge clk)
    config_csr__shadow_en <= \config_csr__shadow_en$next ;
  always @(posedge clk)
    config_csr__w_stb <= \config_csr__w_stb$next ;
  always @(posedge clk)
    config_csr__shadow <= \config_csr__shadow$next ;
  always @(posedge clk)
    status_csr__shadow_en <= \status_csr__shadow_en$next ;
  always @(posedge clk)
    status_csr__w_stb <= \status_csr__w_stb$next ;
  always @(posedge clk)
    status_csr__shadow <= \status_csr__shadow$next ;
  assign \$7  = config_csr__shadow_en ? config_csr__shadow : 32'd0;
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$3 ) begin end
    \config_csr__shadow_en$next  = 1'h0;
    casez (csr__addr)
      1'h0:
          \config_csr__shadow_en$next  = \$2 [0];
    endcase
    casez (rst)
      1'h1:
          \config_csr__shadow_en$next  = 1'h0;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$3 ) begin end
    \config_csr__w_stb$next  = 1'h0;
    casez (csr__addr)
      1'h0:
          \config_csr__w_stb$next  = csr__w_stb;
    endcase
    casez (rst)
      1'h1:
          \config_csr__w_stb$next  = 1'h0;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$3 ) begin end
    config_csr__r_stb = 1'h0;
    casez (csr__addr)
      1'h0:
          config_csr__r_stb = csr__r_stb;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$3 ) begin end
    \config_csr__shadow$next  = config_csr__shadow;
    casez (csr__addr)
      1'h0:
        begin
          casez (csr__r_stb)
            1'h1:
                \config_csr__shadow$next  = config_csr__r_data;
          endcase
          casez (csr__w_stb)
            1'h1:
                \config_csr__shadow$next  = csr__w_data;
          endcase
        end
    endcase
    casez (rst)
      1'h1:
          \config_csr__shadow$next  = 32'd0;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$3 ) begin end
    \status_csr__shadow_en$next  = 1'h0;
    casez (csr__addr)
      1'h1:
          \status_csr__shadow_en$next  = \$5 [0];
    endcase
    casez (rst)
      1'h1:
          \status_csr__shadow_en$next  = 1'h0;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$3 ) begin end
    \status_csr__w_stb$next  = 1'h0;
    casez (csr__addr)
      1'h1:
          \status_csr__w_stb$next  = csr__w_stb;
    endcase
    casez (rst)
      1'h1:
          \status_csr__w_stb$next  = 1'h0;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$3 ) begin end
    status_csr__r_stb = 1'h0;
    casez (csr__addr)
      1'h1:
          status_csr__r_stb = csr__r_stb;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$3 ) begin end
    \status_csr__shadow$next  = status_csr__shadow;
    casez (csr__addr)
      1'h1:
        begin
          casez (csr__r_stb)
            1'h1:
                \status_csr__shadow$next  = status_csr__r_data;
          endcase
          casez (csr__w_stb)
            1'h1:
                \status_csr__shadow$next  = csr__w_data;
          endcase
        end
    endcase
    casez (rst)
      1'h1:
          \status_csr__shadow$next  = 32'd0;
    endcase
  end
  assign \$1  = \$2 ;
  assign \$4  = \$5 ;
  assign csr__r_data = \$13 ;
  assign status_csr__w_data = status_csr__shadow;
  assign config_csr__w_data = config_csr__shadow;
  assign \$2  = { 1'h0, csr__r_stb };
  assign \$5  = { 1'h0, csr__r_stb };
endmodule

module simplebus_host(bus_in, parity_in, bus_out, parity_out, enabled, wb_adr, wb_dat_w, wb_dat_r, wb_sel, wb_cyc, wb_stb, wb_we, wb_ack, wb_stall, wb_ctrl_adr, wb_ctrl_dat_w, wb_ctrl_dat_r, wb_ctrl_sel, wb_ctrl_cyc, wb_ctrl_stb, wb_ctrl_we
, wb_ctrl_ack, wb_ctrl_stall, clk, rst, clk_out);
  input [7:0] bus_in;
  wire [7:0] bus_in;
  output [7:0] bus_out;
  wire [7:0] bus_out;
  input clk;
  wire clk;
  output clk_out;
  wire clk_out;
  output enabled;
  wire enabled;
  wire [7:0] mux_bus_in;
  wire [7:0] mux_bus_out;
  wire mux_clk_out;
  wire mux_enabled;
  wire mux_parity_out;
  wire mux_wb__ack;
  wire [28:0] mux_wb__adr;
  wire mux_wb__cyc;
  wire [63:0] mux_wb__dat_r;
  wire [63:0] mux_wb__dat_w;
  wire [7:0] mux_wb__sel;
  wire mux_wb__stall;
  wire mux_wb__stb;
  wire mux_wb__we;
  wire mux_wb_ctrl__ack;
  wire [29:0] mux_wb_ctrl__adr;
  wire mux_wb_ctrl__cyc;
  wire [31:0] mux_wb_ctrl__dat_r;
  wire [31:0] mux_wb_ctrl__dat_w;
  wire [3:0] mux_wb_ctrl__sel;
  wire mux_wb_ctrl__stb;
  wire mux_wb_ctrl__we;
  wire mux_wb_ctrl_stall;
  input parity_in;
  wire parity_in;
  wire \parity_in$1 ;
  output parity_out;
  wire parity_out;
  input rst;
  wire rst;
  output wb_ack;
  wire wb_ack;
  input [28:0] wb_adr;
  wire [28:0] wb_adr;
  output wb_ctrl_ack;
  wire wb_ctrl_ack;
  input [29:0] wb_ctrl_adr;
  wire [29:0] wb_ctrl_adr;
  input wb_ctrl_cyc;
  wire wb_ctrl_cyc;
  output [31:0] wb_ctrl_dat_r;
  wire [31:0] wb_ctrl_dat_r;
  input [31:0] wb_ctrl_dat_w;
  wire [31:0] wb_ctrl_dat_w;
  input [3:0] wb_ctrl_sel;
  wire [3:0] wb_ctrl_sel;
  output wb_ctrl_stall;
  wire wb_ctrl_stall;
  input wb_ctrl_stb;
  wire wb_ctrl_stb;
  input wb_ctrl_we;
  wire wb_ctrl_we;
  input wb_cyc;
  wire wb_cyc;
  output [63:0] wb_dat_r;
  wire [63:0] wb_dat_r;
  input [63:0] wb_dat_w;
  wire [63:0] wb_dat_w;
  input [7:0] wb_sel;
  wire [7:0] wb_sel;
  output wb_stall;
  wire wb_stall;
  input wb_stb;
  wire wb_stb;
  input wb_we;
  wire wb_we;
  mux mux (
    .bus_in(mux_bus_in),
    .bus_out(mux_bus_out),
    .clk(clk),
    .clk_out(mux_clk_out),
    .enabled(mux_enabled),
    .parity_out(mux_parity_out),
    .rst(rst),
    .wb__ack(mux_wb__ack),
    .wb__adr(mux_wb__adr),
    .wb__cyc(mux_wb__cyc),
    .wb__dat_r(mux_wb__dat_r),
    .wb__dat_w(mux_wb__dat_w),
    .wb__sel(mux_wb__sel),
    .wb__stall(mux_wb__stall),
    .wb__stb(mux_wb__stb),
    .wb__we(mux_wb__we),
    .wb_ctrl__ack(mux_wb_ctrl__ack),
    .wb_ctrl__adr(mux_wb_ctrl__adr),
    .wb_ctrl__cyc(mux_wb_ctrl__cyc),
    .wb_ctrl__dat_r(mux_wb_ctrl__dat_r),
    .wb_ctrl__dat_w(mux_wb_ctrl__dat_w),
    .wb_ctrl__sel(mux_wb_ctrl__sel),
    .wb_ctrl__stb(mux_wb_ctrl__stb),
    .wb_ctrl__we(mux_wb_ctrl__we),
    .wb_ctrl_stall(mux_wb_ctrl_stall)
  );
  assign wb_ctrl_stall = mux_wb_ctrl_stall;
  assign wb_ctrl_ack = mux_wb_ctrl__ack;
  assign wb_ctrl_dat_r = mux_wb_ctrl__dat_r;
  assign mux_wb_ctrl__we = wb_ctrl_we;
  assign mux_wb_ctrl__stb = wb_ctrl_stb;
  assign mux_wb_ctrl__cyc = wb_ctrl_cyc;
  assign mux_wb_ctrl__sel = wb_ctrl_sel;
  assign mux_wb_ctrl__dat_w = wb_ctrl_dat_w;
  assign mux_wb_ctrl__adr = wb_ctrl_adr;
  assign wb_stall = mux_wb__stall;
  assign wb_ack = mux_wb__ack;
  assign wb_dat_r = mux_wb__dat_r;
  assign mux_wb__we = wb_we;
  assign mux_wb__stb = wb_stb;
  assign mux_wb__cyc = wb_cyc;
  assign mux_wb__sel = wb_sel;
  assign mux_wb__dat_w = wb_dat_w;
  assign mux_wb__adr = wb_adr;
  assign enabled = mux_enabled;
  assign clk_out = mux_clk_out;
  assign parity_out = mux_parity_out;
  assign bus_out = mux_bus_out;
  assign \parity_in$1  = parity_in;
  assign mux_bus_in = bus_in;
endmodule
