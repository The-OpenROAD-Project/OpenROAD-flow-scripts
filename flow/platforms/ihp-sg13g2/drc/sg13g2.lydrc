<?xml version="1.0" encoding="utf-8"?>
<!--
 Copyright 2023 IHP PDK Authors

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     https://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->
<klayout-macro>
 <description />
 <version />
 <category>drc</category>
 <prolog />
 <epilog />
 <doc />
 <autorun>false</autorun>
 <autorun-early>false</autorun-early>
 <shortcut />
 <show-in-menu>true</show-in-menu>
 <group-name>drc_scripts</group-name>
 <menu-path>tools_menu.drc.end</menu-path>
 <interpreter>dsl</interpreter>
 <dsl-interpreter-name>drc-dsl-xml</dsl-interpreter-name>
 <text>application = RBA::Application.instance
main_window = application.main_window
curr_layout_view = main_window.current_view()
unless curr_layout_view
    layout_path = RBA::FileDialog::ask_open_file_name("Chose your layout file.", ".", "GDSII files (*.GDS *.gds *.GDS.gz *.gds.gz *.GDS2 *.gds2 *.GDS2.gz *.gds2.gz);; All files (*)")
    main_window.load_layout(layout_path, 1)
    curr_layout_view = main_window.current_view()
end
active_layout = RBA::CellView::active.layout
active_cellname = RBA::CellView::active.cell_name
source(active_layout, active_cellname)
if active_layout.dbu != 0.001
    puts "WARNING: Layout dbu value (" + active_layout.dbu.to_s + " ) deviates from rule file dbu value (0.001). This will scale the layout and may not be intended."
end
report("design rules: sg13g2 | layout cell: " + active_cellname, "sg13g2.lyrdb")

class DRC::DRCEngine
    def space_width_separation_overlap_check(value,
                                             error_edge_pairs_90,
                                             error_edge_pairs_180,
                                             inverse_error_edge_pairs_90 = nil,
                                             inverse_error_edge_pairs_180 = nil,
                                             options = {})
        consider_intersecting_edges   = options.fetch(:consider_intersecting_edges, false)
        consider_touch_points         = options.fetch(:consider_touch_points, false)
        ignore_non_axis_aligned_edges = options.fetch(:ignore_non_axis_aligned_edges, false)
        min_angle                     = options.fetch(:min_angle, 0)
        max_angle                     = options.fetch(:max_angle, 90)
        include_min_angle             = options.fetch(:include_min_angle, true)
        include_max_angle             = options.fetch(:include_max_angle, false)
        area_of_right_angle = value**2/2
        errors_ep = RBA::EdgePairs::new()
        touch_point_errors_ep = RBA::EdgePairs::new()
        intersecting_edges_errors_ep = RBA::EdgePairs::new()
        intersecting_edges_error_candidates = Hash.new()
        error_edge_pairs_90.data.each do |edge_pair|
            ip = edge_pair.first.intersection_point(edge_pair.second)
            if ip
                intersecting_edges_error_candidates[ip] = edge_pair
            else
                errors_ep.insert(edge_pair)
            end
        end
        if consider_intersecting_edges or consider_touch_points
            touch_point_candidates = Hash.new()
            touch_point_errors = Hash.new()
            if inverse_error_edge_pairs_90 and inverse_error_edge_pairs_180
                (inverse_error_edge_pairs_90 + inverse_error_edge_pairs_180).data.each do |edge_pair|
                    ip = edge_pair.first.intersection_point(edge_pair.second)
                    if ip
                        if touch_point_candidates[ip]
                            touch_point_errors[ip] = true
                            touch_point_candidates.delete(ip)
                        else
                            touch_point_candidates[ip] = edge_pair
                        end
                    end
                end
            end
            touch_point_candidates = Hash.new()
            (error_edge_pairs_90 + error_edge_pairs_180).data.each do |edge_pair|
                ip = edge_pair.first.intersection_point(edge_pair.second)
                if ip
                    if edge_pair.area == area_of_right_angle or max_angle == 180
                        intersecting_edges_error_candidates[ip] = edge_pair
                    end
                    if touch_point_errors[ip]
                        touch_point_errors_ep.insert(edge_pair)
                        intersecting_edges_error_candidates.delete(ip)
                    elsif touch_point_candidates[ip]
                        touch_point_errors_ep.insert(edge_pair)
                        touch_point_errors_ep.insert(touch_point_candidates[ip])
                        touch_point_candidates.delete(ip)
                        intersecting_edges_error_candidates.delete(ip)
                    else
                        touch_point_candidates[ip] = edge_pair
                    end
                end
            end
            if consider_intersecting_edges
                intersecting_edges_errors_ep = RBA::EdgePairs::new(intersecting_edges_error_candidates.values)
                if max_angle != 180
                    intersecting_edges_errors_ep = intersecting_edges_errors_ep.with_internal_angle(min_angle, max_angle, false, include_min_angle, include_max_angle)
                end
                errors_ep = errors_ep + intersecting_edges_errors_ep
            end
        end
        if ignore_non_axis_aligned_edges
            errors_ep = errors_ep.with_angle_both(RBA::Edges::OrthoEdges, false)
        end
        if consider_touch_points
            errors_ep = errors_ep + touch_point_errors_ep
        end
        return DRC::DRCLayer::new(self, errors_ep)
    end
end

class DRC::DRCLayer
    def ext_area(constraint)
        output_layer = self.dup 
        constraint.each do |expression|
            output_layer.data.min_coherence = true
            if expression[0] == "&gt;"
                output_layer = output_layer.with_area((expression[1] + 1), nil)
            elsif expression[0] == "&lt;"
                output_layer = output_layer.with_area(nil, expression[1])
            elsif expression[0] == "=="
                output_layer = output_layer.with_area(expression[1])
            elsif expression[0] == "!="
                output_layer = output_layer.without_area(expression[1])
            elsif expression[0] == "&gt;="
                output_layer = output_layer.with_area(expression[1], nil)
            elsif expression[0] == "&lt;="
                output_layer = output_layer.with_area(nil, (expression[1] + 1))
            else
                raise "invalid expression"
            end
        end
        return output_layer
    end

    def ext_constraint_satisfied(value, constraint)
        output_bool = true
        constraint.each do |expression|
            if expression[0] == "&gt;"
                output_bool = output_bool &amp;&amp; (value &gt; expression[1])
            elsif expression[0] == "&lt;"
                output_bool = output_bool &amp;&amp; (value &lt; expression[1])
            elsif expression[0] == "=="
                output_bool = output_bool &amp;&amp; (value == expression[1])
            elsif expression[0] == "!="
               output_bool = output_bool &amp;&amp; (value != expression[1])
            elsif expression[0] == "&gt;="
                output_bool = output_bool &amp;&amp; (value &gt;= expression[1])
            elsif expression[0] == "&lt;="
                output_bool = output_bool &amp;&amp; (value &lt;= expression[1])
            else
                raise "invalid expression"
            end
        end
        return output_bool
    end

    def ext_separation(other,
                       value,
                       metric=RBA::Region::Euclidian,
                       consider_intersecting_edges=false,
                       consider_touch_points=false,
                       ignore_non_axis_aligned_edges=false,
                       min_angle=0,
                       max_angle=90,
                       include_min_angle=true,
                       include_max_angle=false,
                       polygons=false)
        self_min_coherence_state = self.data.min_coherence?
        other_min_coherence_state =  other.data.min_coherence?
        self.data.min_coherence = true
        other.data.min_coherence = true
        error_edge_pairs_90 = DRC::DRCLayer::new(@engine,
            self.data.separation_check(other.data, value, false, metric, 90, 1, nil))
        error_edge_pairs_180 = DRC::DRCLayer::new(@engine,
            self.data.separation_check(other.data, value, false, metric, 180, nil, 1))
        width_error_edge_pairs_90 = DRC::DRCLayer::new(@engine,
            self.data.width_check(value, false, metric, 90, 1, nil) +
            other.data.width_check(value, false, metric, 90, 1, nil))
        width_error_edge_pairs_180 = DRC::DRCLayer::new(@engine,
            self.data.width_check(value, false, metric, 180, nil, 1) +
            other.data.width_check(value, false, metric, 180, nil, 1))
        separation_errors = @engine.space_width_separation_overlap_check(
            value,
            error_edge_pairs_90,
            error_edge_pairs_180,
            width_error_edge_pairs_90,
            width_error_edge_pairs_180,
            {
                consider_intersecting_edges: consider_intersecting_edges,
                consider_touch_points: consider_touch_points,
                ignore_non_axis_aligned_edges: ignore_non_axis_aligned_edges,
                min_angle: min_angle,
                max_angle: max_angle,
                include_min_angle: include_min_angle,
                include_max_angle: include_max_angle
            }
        )
        self.data.min_coherence = self_min_coherence_state
        other.data.min_coherence = other_min_coherence_state
        if polygons
            return separation_errors.polygons.merge(true, 0)
        else
            return separation_errors
        end
    end

    def ext_not(other)
        self_min_coherence_state = self.data.min_coherence?
        other_min_coherence_state =  other.data.min_coherence?
        self.data.min_coherence = true
        other.data.min_coherence = true
        output_layer = self - other
        self.data.min_coherence = self_min_coherence_state
        other.data.min_coherence = other_min_coherence_state
        return output_layer
    end

    def ext_or(other)
        self_min_coherence_state = self.data.min_coherence?
        other_min_coherence_state =  other.data.min_coherence?
        self.data.min_coherence = true
        other.data.min_coherence = true
        output_layer = self | other
        self.data.min_coherence = self_min_coherence_state
        other.data.min_coherence = other_min_coherence_state
        return output_layer
    end

    def ext_rectangle(axis_aligned = false, use_bbox = false, constraint1 = nil, constraint2 = nil, aspect_ratio_constraint = nil, inverted: false)
        self_min_coherence_state = self.data.min_coherence?
        self.data.min_coherence = true
        if !axis_aligned &amp;&amp; !use_bbox
            self_ortho_rectangles = self.rectangles
            self_remains = self.non_rectangles
            self_ortho_rectangles.data.min_coherence = true
            self_remains.data.min_coherence = true
            self_rectangles = DRC::DRCLayer::new(@engine, self_ortho_rectangles.data)
            self_remains.data.each_merged do |self_polygon|
                self_region = RBA::Region::new(self_polygon)
                self_region.min_coherence = true
                if (self_region.corners(-90, -90, 1).size == 4) &amp;&amp; (self_region.edges.size == 4)
                    self_rectangles.data.insert(self_region)
                end
            end
        elsif axis_aligned &amp;&amp; !use_bbox
            self_rectangles = self.rectangles
        elsif use_bbox
            self_rectangles = self
        end
        output_layer = DRC::DRCLayer::new(@engine, RBA::Region::new)
        self_rectangles.data.min_coherence = true
        self_rectangles.data.each_merged do |self_polygon|
            if use_bbox
                self_region_source = RBA::Region::new(self_polygon)
                self_region_source.min_coherence = true
                self_region = self_region_source.extents
            else
                self_region = RBA::Region::new(self_polygon)
            end
            self_region.min_coherence = true
            long_edge = nil
            short_edge = nil
            index = 0 
            self_region.edges.each do |self_edge|
                if index == 0
                    long_edge = self_edge
                elsif index == 1
                    if long_edge.length &gt;= self_edge.length
                        short_edge = self_edge
                    else
                        short_edge = long_edge
                        long_edge = self_edge
                    end
                else
                    break
                end
                index += 1
            end
            aspect_ratio = long_edge.length/short_edge.length.to_f
            if !constraint1 &amp;&amp; !constraint2 &amp;&amp; !aspect_ratio_constraint
                if use_bbox
                    output_layer.data.insert(self_region_source)
                else
                    output_layer.data.insert(self_region)
                end
            elsif !constraint1 &amp;&amp; !constraint2 &amp;&amp; aspect_ratio_constraint
                if ext_constraint_satisfied(aspect_ratio, aspect_ratio_constraint)
                    if use_bbox
                        output_layer.data.insert(self_region_source)
                    else
                        output_layer.data.insert(self_region)
                    end
                end
            elsif constraint1 &amp;&amp; !constraint2 &amp;&amp; !aspect_ratio_constraint
                if ext_constraint_satisfied(long_edge.length, constraint1) || ext_constraint_satisfied(short_edge.length, constraint1)
                    if use_bbox
                        output_layer.data.insert(self_region_source)
                    else
                        output_layer.data.insert(self_region)
                    end
                end
            elsif constraint1 &amp;&amp; !constraint2 &amp;&amp; aspect_ratio_constraint
                if ext_constraint_satisfied(aspect_ratio, aspect_ratio_constraint)
                    if ext_constraint_satisfied(long_edge.length, constraint1) || ext_constraint_satisfied(short_edge.length, constraint1)
                        if use_bbox
                            output_layer.data.insert(self_region_source)
                        else
                            output_layer.data.insert(self_region)
                        end
                    end
                end
            elsif constraint1 &amp;&amp; constraint2 &amp;&amp; !aspect_ratio_constraint
                if (ext_constraint_satisfied(long_edge.length, constraint1) &amp;&amp; ext_constraint_satisfied(short_edge.length, constraint2)) || (ext_constraint_satisfied(short_edge.length, constraint1) &amp;&amp; ext_constraint_satisfied(long_edge.length, constraint2))
                    if use_bbox
                        output_layer.data.insert(self_region_source)
                    else
                        output_layer.data.insert(self_region)
                    end
                end
            elsif constraint1 &amp;&amp; constraint2 &amp;&amp; aspect_ratio_constraint
                if ext_constraint_satisfied(aspect_ratio, aspect_ratio_constraint)
                    if (ext_constraint_satisfied(long_edge.length, constraint1) &amp;&amp; ext_constraint_satisfied(short_edge.length, constraint2)) || (ext_constraint_satisfied(short_edge.length, constraint1) &amp;&amp; ext_constraint_satisfied(long_edge.length, constraint2))
                        if use_bbox
                            output_layer.data.insert(self_region_source)
                        else
                            output_layer.data.insert(self_region)
                        end
                    end
                end
            else
                raise "second constraint is not allowed without first constraint"
            end
        end
        if inverted
            output_layer = self - output_layer
        end
        self.data.min_coherence = self_min_coherence_state
        return output_layer
    end

    def ext_space(value,
                  metric=RBA::Region::Euclidian,
                  consider_intersecting_edges=false,
                  consider_touch_points=false,
                  ignore_non_axis_aligned_edges=false,
                  min_angle=0,
                  max_angle=90,
                  include_min_angle=true,
                  include_max_angle=false,
                  polygons=false)
        self_min_coherence_state = self.data.min_coherence?
        self.data.min_coherence = true
        error_edge_pairs_90 = DRC::DRCLayer::new(@engine, self.data.space_check(value, false, metric, 90, 1, nil))
        error_edge_pairs_180 = DRC::DRCLayer::new(@engine, self.data.space_check(value, false, metric, 180, nil, 1))
        width_error_edge_pairs_90 = DRC::DRCLayer::new(@engine, self.data.width_check(value, false, metric, 90, 1, nil))
        width_error_edge_pairs_180 = DRC::DRCLayer::new(@engine, self.data.width_check(value, false, metric, 180, nil, 1))
        space_errors = @engine.space_width_separation_overlap_check(
            value,
            error_edge_pairs_90,
            error_edge_pairs_180,
            width_error_edge_pairs_90,
            width_error_edge_pairs_180,
            {
                consider_intersecting_edges: consider_intersecting_edges,
                consider_touch_points: consider_touch_points,
                ignore_non_axis_aligned_edges: ignore_non_axis_aligned_edges,
                min_angle: min_angle,
                max_angle: max_angle,
                include_min_angle: include_min_angle,
                include_max_angle: include_max_angle
            }
        )
        self.data.min_coherence = self_min_coherence_state
        if polygons
            return space_errors.polygons.merge(true, 0)
        else
            return space_errors
        end
    end

    def ext_width(value,
                  metric=RBA::Region::Euclidian,
                  consider_intersecting_edges=false,
                  consider_touch_points=false,
                  ignore_non_axis_aligned_edges=false,
                  min_angle=0,
                  max_angle=90,
                  include_min_angle=true,
                  include_max_angle=false,
                  polygons=false)
        self_min_coherence_state = self.data.min_coherence?
        self.data.min_coherence = true
        error_edge_pairs_90 = DRC::DRCLayer::new(@engine, self.data.width_check(value, false, metric, 90, 1, nil))
        error_edge_pairs_180 = DRC::DRCLayer::new(@engine, self.data.width_check(value, false, metric, 180, nil, 1))
        space_error_edge_pairs_90 = DRC::DRCLayer::new(@engine, self.data.space_check(value, false, metric, 90, 1, nil))
        space_error_edge_pairs_180 = DRC::DRCLayer::new(@engine, self.data.space_check(value, false, metric, 180, nil, 1))
        width_errors = @engine.space_width_separation_overlap_check(
            value,
            error_edge_pairs_90,
            error_edge_pairs_180,
            space_error_edge_pairs_90,
            space_error_edge_pairs_180,
            {
                consider_intersecting_edges: consider_intersecting_edges,
                consider_touch_points: consider_touch_points,
                ignore_non_axis_aligned_edges: ignore_non_axis_aligned_edges,
                min_angle: min_angle,
                max_angle: max_angle,
                include_min_angle: include_min_angle,
                include_max_angle: include_max_angle
            }
        )
        self.data.min_coherence = self_min_coherence_state
        if polygons
            return width_errors.polygons.merge(true, 0)
        else
            return width_errors
        end
    end

    def ext_ring
        holes = self.holes
        hulls = self.hulls
        covering = hulls.covering(holes)
        result = covering.and(self)
        return result
    end

    def ext_with_density(range, *args)
        if self.is_empty?
            return DRC::DRCLayer::new(@engine, RBA::Region::new())
        end
        origin = 'cc'
        tile_size = nil
        tile_step = nil
        arguments = [range]
        args.each do |a|
            if a.is_a?(DRC::DRCTileSize)
                tile_size = a
                arguments.push(tile_size)
            elsif a.is_a?(DRC::DRCTileStep)
                tile_step = a
                arguments.push(tile_step)
            elsif a.is_a?(String)
                origin = a
            else
                raise "argument error"
            end
        end
        bbox = @engine.extent.bbox
        if origin == 'll'
            origin_x = bbox.left
            origin_y = bbox.bottom
            tile_origin = DRC::DRCTileOrigin::new(origin_x, origin_y)
            arguments.push(tile_origin)
        elsif origin != 'cc'
            raise "Unkown origin: 'cc' or 'll' expected"
        end
        if tile_size
            return self.with_density(*arguments)
        else
            tile_size = DRC::DRCTileSize::new(bbox.width, bbox.height)
            tile_count = DRC::DRCTileCount::new(1,2)
            enlarged_bbox = bbox.enlarged(1.1).to_itype(@engine.dbu)
            boundary_layer = DRC::DRCLayer::new(@engine, RBA::Region::new(enlarged_bbox))
            tile_boundary = DRC::DRCTileBoundary::new(boundary_layer)
            result = self.with_density(*arguments, tile_size, tile_count, tile_boundary)
            return result.raw.overlapping(DRC::DRCLayer::new(@engine, RBA::Region::new(bbox.to_itype(@engine.dbu))))
        end
    end
end

NWell_org = source.polygons("31/0")
NWell_pin_org = source.polygons("31/2")
Activ_org = source.polygons("1/0")
Activ_pin_org = source.polygons("1/2")
Activ_filler_org = source.polygons("1/22")
ThickGateOx_org = source.polygons("44/0")
GatPoly_org = source.polygons("5/0")
GatPoly_pin_org = source.polygons("5/2")
GatPoly_filler_org = source.polygons("5/22")
Cont_org = source.polygons("6/0")
Metal1_org = source.polygons("8/0")
Metal1_pin_org = source.polygons("8/2")
Metal1_filler_org = source.polygons("8/22")
Metal1_slit_org = source.polygons("8/24")
Via1_org = source.polygons("19/0")
Metal2_org = source.polygons("10/0")
Metal2_pin_org = source.polygons("10/2")
Metal2_filler_org = source.polygons("10/22")
Metal2_slit_org = source.polygons("10/24")
Via2_org = source.polygons("29/0")
Metal3_org = source.polygons("30/0")
Metal3_pin_org = source.polygons("30/2")
Metal3_filler_org = source.polygons("30/22")
Metal3_slit_org = source.polygons("30/24")
Via3_org = source.polygons("49/0")
Metal4_org = source.polygons("50/0")
Metal4_pin_org = source.polygons("50/2")
Metal4_filler_org = source.polygons("50/22")
Metal4_slit_org = source.polygons("50/24")
Via4_org = source.polygons("66/0")
Metal5_org = source.polygons("67/0")
Metal5_pin_org = source.polygons("67/2")
Metal5_filler_org = source.polygons("67/22")
Metal5_slit_org = source.polygons("67/24")
TopVia1_org = source.polygons("125/0")
TopMetal1_org = source.polygons("126/0")
TopMetal1_pin_org = source.polygons("126/2")
TopMetal1_filler_org = source.polygons("126/22")
TopMetal1_slit_org = source.polygons("126/24")
Vmim_org = source.polygons("129/0")
TopVia2_org = source.polygons("133/0")
TopMetal2_org = source.polygons("134/0")
TopMetal2_pin_org = source.polygons("134/2")
TopMetal2_filler_org = source.polygons("134/22")
TopMetal2_slit_org = source.polygons("134/24")
Passiv_org = source.polygons("9/0")
EdgeSeal_org = source.polygons("39/0")
BiWind_org = source.polygons("3/0")
PEmWind_org = source.polygons("11/0")
BasPoly_org = source.polygons("13/0")
DeepCo_org = source.polygons("35/0")
PEmPoly_org = source.polygons("70/0", "53/0")
EmPoly_org = source.polygons("55/0")
LDMOS_org = source.polygons("57/0")
PBiWind_org = source.polygons("58/0")
Flash_org = source.polygons("71/0")
ColWind_org = source.polygons("139/0")
SRAM_org = source.polygons("25/0")
NoDRC = source.polygons("62/0")
LBE_org = source.polygons("157/0")
NWell = NWell_org.ext_not(NoDRC)
Activ = Activ_org.ext_not(NoDRC)
ThickGateOx = ThickGateOx_org.ext_not(NoDRC)
GatPoly = GatPoly_org.ext_not(NoDRC)
Cont = Cont_org.ext_not(NoDRC)
ActFiller = Activ_filler_org.ext_not(NoDRC)
GatFiller = GatPoly_filler_org.ext_not(NoDRC)
Activ_pin = Activ_pin_org.ext_not(NoDRC)
GatPoly_pin = GatPoly_pin_org.ext_not(NoDRC)
NWell_pin = NWell_pin_org.ext_not(NoDRC)
Metal1 = Metal1_org.ext_not(NoDRC)
Via1 = Via1_org.ext_not(NoDRC)
Metal2 = Metal2_org.ext_not(NoDRC)
Via2 = Via2_org.ext_not(NoDRC)
Metal3 = Metal3_org.ext_not(NoDRC)
Via3 = Via3_org.ext_not(NoDRC)
Metal4 = Metal4_org.ext_not(NoDRC)
Via4 = Via4_org.ext_not(NoDRC)
Metal5 = Metal5_org.ext_not(NoDRC)
Vmim = Vmim_org.ext_not(NoDRC)
TopMetal1 = TopMetal1_org.ext_not(NoDRC)
TopVia2 = TopVia2_org.ext_not(NoDRC)
TopMetal2 = TopMetal2_org.ext_not(NoDRC)
Passiv = Passiv_org.ext_not(NoDRC)
EdgeSeal = EdgeSeal_org.ext_not(NoDRC)
M1Filler = Metal1_filler_org.ext_not(NoDRC)
M2Filler = Metal2_filler_org.ext_not(NoDRC)
M3Filler = Metal3_filler_org.ext_not(NoDRC)
M4Filler = Metal4_filler_org.ext_not(NoDRC)
M5Filler = Metal5_filler_org.ext_not(NoDRC)
TopMet1Filler = TopMetal1_filler_org.ext_not(NoDRC)
TopMet2Filler = TopMetal2_filler_org.ext_not(NoDRC)
M1Slit = Metal1_slit_org.ext_not(NoDRC)
M2Slit = Metal2_slit_org.ext_not(NoDRC)
M3Slit = Metal3_slit_org.ext_not(NoDRC)
M4Slit = Metal4_slit_org.ext_not(NoDRC)
M5Slit = Metal5_slit_org.ext_not(NoDRC)
TopMet1Slit = TopMetal1_slit_org.ext_not(NoDRC)
TopMet2Slit = TopMetal2_slit_org.ext_not(NoDRC)
Metal1_pin = Metal1_pin_org.ext_not(NoDRC)
Metal2_pin = Metal2_pin_org.ext_not(NoDRC)
Metal3_pin = Metal3_pin_org.ext_not(NoDRC)
Metal4_pin = Metal4_pin_org.ext_not(NoDRC)
Metal5_pin = Metal5_pin_org.ext_not(NoDRC)
TopMetal1_pin = TopMetal1_pin_org.ext_not(NoDRC)
TopMetal2_pin = TopMetal2_pin_org.ext_not(NoDRC)
SRAM = SRAM_org.ext_not(NoDRC)
LBE = LBE_org.ext_not(NoDRC)
TopVia1 = NoDRC.ext_or(Vmim_org).ext_or(TopVia1_org.ext_not(NoDRC))
Activ_Act_a = Activ.ext_width(150, RBA::Region::Euclidian, true, true, false, 0, 90, true, false, false)
ThickGateOx_TGO_f = ThickGateOx.ext_width(860, RBA::Region::Euclidian, false, true, false, 0, 180, true, false, true)
Cont_SQ = Cont.ext_rectangle(true, false, [["==", 160]], [["==", 160]], nil)
Act_density = ActFiller.ext_or(Activ)
Gat_density = GatFiller.ext_or(GatPoly)
Act_Nsram = Activ.ext_not(SRAM)
GP_Nsram = GatPoly.ext_not(SRAM)
M1_Nsram = Metal1.ext_not(SRAM)
M2_Nsram = Metal2.ext_not(SRAM)
M3_Nsram = Metal3.ext_not(SRAM)
M4_Nsram = Metal4.ext_not(SRAM)
M5_Nsram = Metal5.ext_not(SRAM)
M1_density = M1Filler.ext_or(Metal1).ext_not(M1Slit)
M2_density = M2Filler.ext_or(Metal2).ext_not(M2Slit)
M3_density = M3Filler.ext_or(Metal3).ext_not(M3Slit)
M4_density = M4Filler.ext_or(Metal4).ext_not(M4Slit)
M5_density = M5Filler.ext_or(Metal5).ext_not(M5Slit)
TM1_density = TopMet1Filler.ext_or(TopMetal1).ext_not(TopMet1Slit)
TM2_density = TopMet2Filler.ext_or(TopMetal2).ext_not(TopMet2Slit)
GP_Nsram_Gat_a = GP_Nsram.ext_width(130, RBA::Region::Euclidian, false, true, false, 0, 180, true, false, true)
GP_Nsram_Gat_b = GP_Nsram.ext_space(180, RBA::Region::Euclidian, false, true, false, 0, 180, true, false, true)

-&gt; do
    BiWind_org.dup
end.().output("forbidden.BiWind", "Biwind forbidden layer in 0.13um designs")

-&gt; do
    PEmWind_org.dup
end.().output("forbidden.PEmWind", "PEmWind forbidden layer in 0.13um designs")

-&gt; do
    BasPoly_org.dup
end.().output("forbidden.BasPoly", "BasPoly forbidden layer in 0.13um designs")

-&gt; do
    DeepCo_org.dup
end.().output("forbidden.DeepCo", "DeepCo forbidden layer in 0.13um designs")

-&gt; do
    PEmPoly_org.dup
end.().output("forbidden.PEmPoly", "PEmPoly forbidden layer in 0.13um designs")

-&gt; do
    EmPoly_org.dup
end.().output("forbidden.EmPoly", "EmPoly forbidden layer in 0.13um designs")

-&gt; do
    LDMOS_org.dup
end.().output("forbidden.LDMOS", "LDMOS forbidden layer in 0.13um designs")

-&gt; do
    PBiWind_org.dup
end.().output("forbidden.PBiWind", "PBiWind forbidden layer in 0.13um designs")

-&gt; do
    Flash_org.dup
end.().output("forbidden.Flash", "Flash forbidden layer in 0.13um designs")

-&gt; do
    ColWind_org.dup
end.().output("forbidden.ColWind", "ColWind forbidden layer in 0.13um designs")

-&gt; do
    Activ_pin.ext_not(Activ)
end.().output("forbidden.a", "Activ enclosure of Activ_pin = 0.0")

-&gt; do
    GatPoly_pin.ext_not(GatPoly)
end.().output("forbidden.b", "GatPoly enclosure of GatPoly_pin = 0.0")

-&gt; do
    NWell_pin.ext_not(NWell)
end.().output("forbidden.c", "NWell enclosure of NWell_pin = 0.0")

-&gt; do
    Metal1.ext_width(160, RBA::Region::Euclidian, true, true, false, 0, 90, true, false, false)
end.().output("M1.a", "Min. width of Metal1 = 0.16")

-&gt; do
    Metal2.ext_width(200, RBA::Region::Euclidian, true, true, false, 0, 90, true, false, false)
end.().output("M2.a", "Min. width of Metal2 = 0.2")

-&gt; do
    Metal3.ext_width(200, RBA::Region::Euclidian, true, true, false, 0, 90, true, false, false)
end.().output("M3.a", "Min. width of Metal3 = 0.2")

-&gt; do
    Metal4.ext_width(200, RBA::Region::Euclidian, true, true, false, 0, 90, true, false, false)
end.().output("M4.a", "Min. width of Metal4 = 0.2")

-&gt; do
    Metal5.ext_width(200, RBA::Region::Euclidian, true, true, false, 0, 90, true, false, false)
end.().output("M5.a", "Min. width of Metal5 = 0.2")

-&gt; do
    TopMetal1.ext_width(1640, RBA::Region::Euclidian, true, true, false, 0, 90, true, false, false)
end.().output("TM1.a", "Min. width of TopMetal1 = 1.64")

-&gt; do
    TopMetal1.ext_space(1640, RBA::Region::Euclidian, true, true, false, 0, 90, true, false, false)
end.().output("TM1.b", "Min. TopMetal1 space or notch = 1.64")

-&gt; do
    TopVia2.ext_space(1060, RBA::Region::Euclidian, true, true, false, 0, 90, true, false, false)
end.().output("TV2.b", "Min. TopVia2 space = 1.06")

-&gt; do
    TopMetal2.ext_width(2000, RBA::Region::Euclidian, true, true, false, 0, 90, true, false, false)
end.().output("TM2.a", "Min. width of TopMetal2 = 2.0")

-&gt; do
    TopMetal2.ext_space(2000, RBA::Region::Euclidian, true, true, false, 0, 90, true, false, false)
end.().output("TM2.b", "Min. TopMetal2 space or notch = 2.0")

-&gt; do
    Passiv.ext_width(2100, RBA::Region::Euclidian, true, true, false, 0, 90, true, false, false)
end.().output("Pas.a", "Min. Passiv width = 2.10")

-&gt; do
    Passiv.ext_space(3500, RBA::Region::Euclidian, true, true, false, 0, 90, true, false, false)
end.().output("Pas.b", "Min. Passiv space or notch = 3.50")

-&gt; do
    Metal1_pin.ext_not(Metal1)
end.().output("forbidden.d", "Metal1 enclosure of Metal1_pin = 0.0")

-&gt; do
    Metal2_pin.ext_not(Metal2)
end.().output("forbidden.f.M1", "Metal2 enclosure of Metal2_pin = 0.0")

-&gt; do
    Metal3_pin.ext_not(Metal3)
end.().output("forbidden.f.M2", "Metal3 enclosure of Metal3_pin = 0.0")

-&gt; do
    Metal4_pin.ext_not(Metal4)
end.().output("forbidden.f.M3", "Metal4 enclosure of Metal4_pin = 0.0")

-&gt; do
    Metal5_pin.ext_not(Metal5)
end.().output("forbidden.f.M4", "Metal5 enclosure of Metal5_pin = 0.0")

-&gt; do
    TopMetal1_pin.ext_not(TopMetal1)
end.().output("forbidden.f.M5", "TopMetal1 enclosure of TopMetal1_pin = 0.0")

-&gt; do
    TopMetal2_pin.ext_not(TopMetal2)
end.().output("forbidden.f.MT1", "TopMetal2 enclosure of TopMetal2_pin = 0.0")

-&gt; do
    LBE.ext_with_density(0.2 .. 1.0, 'll')
end.().output("LBE.i", "Max. global LBE density [%] = 20.0 %")

-&gt; do
    LBE.ext_width(100000, RBA::Region::Euclidian, true, true, false, 0, 90, true, false, false)
end.().output("LBE.a", "LBE.a: Min. width of LBE = 100.0")

-&gt; do
    LBE.drc(width &gt; 1500000)
end.().output("LBE.b", "LBE.b: Max. width of LBE = 1500.0")

-&gt; do
    LBE.ext_area([["&gt;", 250000.0*1000.0*1000.0]])
end.().output("LBE.b1", "LBE.b1: Max allowed LBE area = 250000.0")

-&gt; do
    LBE.ext_space(100000, RBA::Region::Euclidian, false, true, true, 0, 180, true, false, false)
end.().output("LBE.c", "LBE.c: Min. LBE space or notch = 100.0")

-&gt; do
    Cont.merged(true, 0).outside(EdgeSeal).ext_space(180, RBA::Region::Euclidian, false, true, false, 0, 180, true, false, false)
end.().output("Cnt.b", "Min. Cont space = 0.18")

-&gt; do
    Via1.ext_not(EdgeSeal).ext_rectangle(false, false, [["==", 190]], [["==", 190]], nil, inverted: true)
end.().output("Via1.a", "Via1.a: Min. and Maxi. size of Via1 = 0.19")

-&gt; do
    Via1.ext_not(EdgeSeal).ext_space(220, RBA::Region::Euclidian, false, true, false, 0, 180, true, false, false)
end.().output("Via1.b", "Via1.b: Min. Via1 space = 0.22")

-&gt; do
    Via2.ext_not(EdgeSeal).ext_rectangle(false, false, [["==", 190]], [["==", 190]], nil, inverted: true)
end.().output("Via2.a", "Via2.a: Min. and Maxi. size of Via2 = 0.19")

-&gt; do
    Via2.ext_not(EdgeSeal).ext_space(220, RBA::Region::Euclidian, false, true, false, 0, 180, true, false, false)
end.().output("Via2.b", "Via2.b: Min. Via2 space = 0.22")

-&gt; do
    Via3.ext_not(EdgeSeal).ext_rectangle(false, false, [["==", 190]], [["==", 190]], nil, inverted: true)
end.().output("Via3.a", "Via3.a: Min. and Maxi. size of Via3 = 0.19")

-&gt; do
    Via3.ext_not(EdgeSeal).ext_space(220, RBA::Region::Euclidian, false, true, false, 0, 180, true, false, false)
end.().output("Via3.b", "Via3.b: Min. Via3 space = 0.22")

-&gt; do
    Via4.ext_not(EdgeSeal).ext_rectangle(false, false, [["==", 190]], [["==", 190]], nil, inverted: true)
end.().output("Via4.a", "Via4.a: Min. and Maxi. size of Via4 = 0.19")

-&gt; do
    Via4.ext_not(EdgeSeal).ext_space(220, RBA::Region::Euclidian, false, true, false, 0, 180, true, false, false)
end.().output("Via4.b", "Via4.b: Min. Via4 space = 0.22")

-&gt; do
    TopVia2.ext_not(EdgeSeal).ext_rectangle(false, false, [["==", 900]], [["==", 900]], nil, inverted: true)
end.().output("TV2.a", "Min.and Max. TopVia2 = 0.90")

-&gt; do
    LBE.ext_ring.dup
end.().output("LBE.h", "LBE.h: No LBE ring allowed")

-&gt; do
    Activ_Act_a.dup
end.().output("Act.a", "Min. Activ width = 0.15")

-&gt; do
    ThickGateOx_TGO_f.dup
end.().output("TGO.f", "Min. ThickGateOx width = 0.86")

-&gt; do
    Cont.merged(true, 0).outside(EdgeSeal).ext_not(Cont_SQ)
end.().output("Cnt.a", "Min.and max. size of Cont = 0.16")

-&gt; do
    Act_density.ext_with_density(0.0 .. 0.35, 'll')
end.().output("aFil.g", "Min. global Activ coverage = 35.0 %")

-&gt; do
    Act_density.ext_with_density(0.55 .. 1.0, 'll')
end.().output("aFil.g1", "Max. global Activ coverage = 55.0 %")

-&gt; do
    Act_density.ext_with_density(0.0 .. 0.25, 'll', tile_size(800.0), tile_step(400.0))
end.().output("aFil.g2", "Min. Active coverage ratio for any 800 x 800 µm² chip area = 25.0 %")

-&gt; do
    Act_density.ext_with_density(0.65 .. 1.0, 'll', tile_size(800.0), tile_step(400.0))
end.().output("aFil.g3", "Max. Active coverage ratio for any 800 x 800 µm² chip area = 65.0 %")

-&gt; do
    Gat_density.ext_with_density(0.0 .. 0.15, 'll')
end.().output("GFil.g", "Min. global GatPoly density [%] = 15.0")

-&gt; do
    TopVia1.ext_or(Vmim).ext_space(420, RBA::Region::Euclidian, true, true, false, 0, 90, true, false, false)
end.().output("TV1.b", "Min. TopVia1 space = 0.42")

-&gt; do
    Act_Nsram.ext_space(210, RBA::Region::Euclidian, true, true, false, 0, 90, true, false, false)
end.().output("Act.b", "Act.b: Min. Activ space or notch = 0.21")

-&gt; do
    GP_Nsram.ext_separation(Act_Nsram, 70, RBA::Region::Euclidian, true, true, false, 0, 90, true, false, false)
end.().output("Gat.d", "Min. GatPoly to Activ space = 0.07")

-&gt; do
    M1_Nsram.ext_space(180, RBA::Region::Euclidian, false, true, true, 0, 180, true, false, false)
end.().output("M1.b", "Min. Metal1 space or notch = 0.18")

-&gt; do
    M2_Nsram.ext_space(210, RBA::Region::Euclidian, false, true, true, 0, 180, true, false, false)
end.().output("M2.b", "Min. Metal2 space or notch = 0.21")

-&gt; do
    M3_Nsram.ext_space(210, RBA::Region::Euclidian, false, true, true, 0, 180, true, false, false)
end.().output("M3.b", "Min. Metal3 space or notch = 0.21")

-&gt; do
    M4_Nsram.ext_space(210, RBA::Region::Euclidian, false, true, true, 0, 180, true, false, false)
end.().output("M4.b", "Min. Metal4 space or notch = 0.21")

-&gt; do
    M5_Nsram.ext_space(210, RBA::Region::Euclidian, false, true, true, 0, 180, true, false, false)
end.().output("M5.b", "Min. Metal5 space or notch = 0.21")

-&gt; do
    Vmim.ext_or(TopVia1.ext_not(EdgeSeal)).ext_rectangle(false, false, [["==", 420]], [["==", 420]], nil, inverted: true)
end.().output("TV1.a", "Min.and Max. TopVia1 (μm2) = 0.42")

-&gt; (;lbe_in_seal) do
    lbe_in_seal = LBE.merged(true, 0).inside(EdgeSeal.holes.merge)
    lbe_in_seal.ext_separation(EdgeSeal, 150000, RBA::Region::Euclidian, false, true, true, 0, 180, true, false, false)
end.().output("LBE.d", "LBE.d: Min. space of LBE to inner edge of Edge Seal = 150.0")

-&gt; do
    M1_density.ext_with_density(0.0 .. 0.35, 'll')
end.().output("M1.j", "Min. global Metal1 density [%] = 35.0")

-&gt; do
    M1_density.ext_with_density(0.6 .. 1.0, 'll')
end.().output("M1.k", "Max. global Metal1 density [%] = 60.0")

-&gt; do
    M1_density.ext_with_density(0.0 .. 0.25, 'll', tile_size(800.0), tile_step(400.0))
end.().output("M1Fil.h", "Min. Metal coverage MM1Filler ratio for any 800 x 800 µm² chip area [%] = 25.0")

-&gt; do
    M1_density.ext_with_density(0.75 .. 1.0, 'll', tile_size(800.0), tile_step(400.0))
end.().output("M1Fil.k", "Max. Metal coverage MM1Filler ratio for any 800 x 800 µm² chip area [%] = 75.0")

-&gt; do
    M2_density.ext_with_density(0.0 .. 0.35, 'll')
end.().output("M2.j", "Min. global Metal2 density [%] = 35.0")

-&gt; do
    M2_density.ext_with_density(0.6 .. 1.0, 'll')
end.().output("M2.k", "Max. global Metal2 density [%] = 60.0")

-&gt; do
    M2_density.ext_with_density(0.0 .. 0.25, 'll', tile_size(800.0), tile_step(400.0))
end.().output("M2Fil.h", "Min. Metal coverage MM2Filler ratio for any 800 x 800 µm² chip area [%] = 25.0")

-&gt; do
    M2_density.ext_with_density(0.75 .. 1.0, 'll', tile_size(800.0), tile_step(400.0))
end.().output("M2Fil.k", "Max. Metal coverage MM2Filler ratio for any 800 x 800 µm² chip area [%] = 75.0")

-&gt; do
    M3_density.ext_with_density(0.0 .. 0.35, 'll')
end.().output("M3.j", "Min. global Metal3 density [%] = 35.0")

-&gt; do
    M3_density.ext_with_density(0.6 .. 1.0, 'll')
end.().output("M3.k", "Max. global Metal3 density [%] = 60.0")

-&gt; do
    M3_density.ext_with_density(0.0 .. 0.25, 'll', tile_size(800.0), tile_step(400.0))
end.().output("M3Fil.h", "Min. Metal coverage MM3Filler ratio for any 800 x 800 µm² chip area [%] = 25.0")

-&gt; do
    M3_density.ext_with_density(0.75 .. 1.0, 'll', tile_size(800.0), tile_step(400.0))
end.().output("M3Fil.k", "Max. Metal coverage MM3Filler ratio for any 800 x 800 µm² chip area [%] = 75.0")

-&gt; do
    M4_density.ext_with_density(0.0 .. 0.35, 'll')
end.().output("M4.j", "Min. global Metal4 density [%] = 35.0")

-&gt; do
    M4_density.ext_with_density(0.6 .. 1.0, 'll')
end.().output("M4.k", "Max. global Metal4 density [%] = 60.0")

-&gt; do
    M4_density.ext_with_density(0.0 .. 0.25, 'll', tile_size(800.0), tile_step(400.0))
end.().output("M4Fil.h", "Min. Metal coverage MM4Filler ratio for any 800 x 800 µm² chip area [%] = 25.0")

-&gt; do
    M4_density.ext_with_density(0.75 .. 1.0, 'll', tile_size(800.0), tile_step(400.0))
end.().output("M4Fil.k", "Max. Metal coverage MM4Filler ratio for any 800 x 800 µm² chip area [%] = 75.0")

-&gt; do
    M5_density.ext_with_density(0.0 .. 0.35, 'll')
end.().output("M5.j", "Min. global Metal5 density [%] = 35.0")

-&gt; do
    M5_density.ext_with_density(0.6 .. 1.0, 'll')
end.().output("M5.k", "Max. global Metal5 density [%] = 60.0")

-&gt; do
    M5_density.ext_with_density(0.0 .. 0.25, 'll', tile_size(800.0), tile_step(400.0))
end.().output("M5Fil.h", "Min. Metal coverage MM5Filler ratio for any 800 x 800 µm² chip area [%] = 25.0")

-&gt; do
    M5_density.ext_with_density(0.75 .. 1.0, 'll', tile_size(800.0), tile_step(400.0))
end.().output("M5Fil.k", "Max. Metal coverage MM5Filler ratio for any 800 x 800 µm² chip area [%] = 75.0")

-&gt; do
    TM1_density.ext_with_density(0.0 .. 0.25, 'll', tile_size(800.0), tile_step(400.0))
end.().output("TM1Fil.h", "Min. Metal coverage MTM1Filler ratio for any 800 x 800 µm² chip area [%] = 25.0")

-&gt; do
    TM1_density.ext_with_density(0.75 .. 1.0, 'll', tile_size(800.0), tile_step(400.0))
end.().output("TM1Fil.k", "Max. Metal coverage MTM1Filler ratio for any 800 x 800 µm² chip area [%] = 75.0")

-&gt; do
    TM1_density.ext_with_density(0.0 .. 0.25, 'll')
end.().output("TM1.c", "Min. global TopMetal1 density [%] = 25.00")

-&gt; do
    TM1_density.ext_with_density(0.7 .. 1.0, 'll')
end.().output("TM1.d", "Max. global TopMetal1 density [%] = 70.00")

-&gt; do
    TM2_density.ext_with_density(0.0 .. 0.25, 'll', tile_size(800.0), tile_step(400.0))
end.().output("TM2Fil.h", "Min. Metal coverage MTM2Filler ratio for any 800 x 800 µm² chip area [%] = 25.0")

-&gt; do
    TM2_density.ext_with_density(0.75 .. 1.0, 'll', tile_size(800.0), tile_step(400.0))
end.().output("TM2Fil.k", "Max. Metal coverage MTM2Filler ratio for any 800 x 800 µm² chip area [%] = 75.0")

-&gt; do
    TM2_density.ext_with_density(0.0 .. 0.25, 'll')
end.().output("TM2.c", "Min. global TopMetal1 density [%] = 25.0")

-&gt; do
    TM2_density.ext_with_density(0.7 .. 1.0, 'll')
end.().output("TM2.c1", "Max. global TopMetal1 density [%] = 70.0")

-&gt; do
    GP_Nsram_Gat_a.dup
end.().output("Gat.a", "Min GatPoly width = 0.13")

-&gt; do
    GP_Nsram_Gat_b.dup
end.().output("Gat.b", "Min. GatPoly space or notch = 0.18")
</text>
</klayout-macro>
